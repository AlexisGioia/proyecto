var es global, es propenso a errores, mejor usar let que tiene alcance de bloque
switch se usa asi:
switch (expresion) {
  case valor1:
    // Código si expresion === valor1
    break;

  case valor2:
    // Código si expresion === valor2
    break;

  default:
    // Código si ningún case coincide
    break;
}
estructuras:
while vs do while: while primero verifica la variable luego ejecuta el bucle, por el contrario do while primero ejecuta y luego verifica el bucle
let j = 0;

do {
  console.log("do while:", j);
  j++;
} while (j < 3);

metodos de arrays:
push() // le agrega al final uno o varios items separados por comas a un array
pop()// elimina el último item del array, devuelve el mismo elemento eliminado 
array.shift() // elimina el primer item de un array
array.unshift() añade uno o varios items al principio del array separados por comas. retorna la longitud nueva.
array.join(separador) // une todos los items en un string separados con un separador.
array.indexOf(contenido) // busca un item con el contenido y devuelve un indice
array.lastIndexOf(contenido) // igual que indexif solo que funciona a la inversa. comienza por el final del arreglo 
array.includes(contenido) // devuelve un booleano al buscar en el array
metodos de strings:
str.lenght // devuelve el largo
str.indexOf(contenido) // busca una cadena y devuelve el índice donde lo encontro
str.slice() // corta la cadena, inicio fin o con valores negativos, cuenta desde atra a delante
str.trim() quita espacios del comienzo y final
str.split(separador) // parte la cadena y la devuelve en un array
str.replace(A,B // busca A en el string y lo reemplaza por B

crear objetos:
para crear un objeto primero se lo asigna a una variable. luego se lo encierra entre ,{} añadiendo adentro propiedades al estiolo propiedad:valor separado por comas

cargar nueva propiedad:
objeto.propiedadNueva="zzzz";
para modificarla simplemente es objeto.propiedad = propiedad_modificada;

para eliminar una propiedad se usa:
delete objeto.propiedad;

crear un método:
es igual a crear una propiedad solo que con funciones. queda asi:
propiedad: function(){}
para llamarlo es igual que para obtener una propiedad 

funciones:
si se le pone un "= valor" a un parametro este se toma por defecto en caso de que se omita al llamar a la funcion
funciones declaradas son las expresadas directamente en el codigo. la principal ventaja es que pueden ser llamadas incluso antes de ser defnidas.
funciones expresadas: son aquellas que se definen dentro de una variable ej: let suma = function(num,num2){}
console.log(suma(1,2));
funciones arrow: son mas simples pero no tienen this. ej let multiplicacion = (num,num2) => {num*num2}

callbacks: funciones que se ejecutan en otras. si la funcion secundaria necesita tener pasados parámetros la función primaria se los asigna dentro de su bloque de codigo. entonces la función secundaria no necesita parentesis ej:
function cocinar(ingrediente, callback) {
    console.log(`Cocinando ${ingrediente}...`);
    setTimeout(() => {
        console.log(`${ingrediente} listo.`);
        callback(ingrediente); // se llama al callback cuando termina
    }, 2000);
}

function servir(plato) {
    console.log(`Sirviendo el ${plato} en la mesa.`);
}

// Uso
cocinar("pasta", servir);


metodos de arrays:
.forEach(callback): crea una funcion anidada entre parentesis con dos parmetros, recorre todos los items de una matriz, al primer parametro se le da el valor del item y al segundo del step o indice
slice(inicio,fin): corta el array a partir y hacia donde se indica.
splice(inicio,cant. elem. a elim.,"elemento1", elemento2..) combina el contenido de un array eliminando elementos existentes a partir del inicio o agregando nuevos elementos en su lugar
.sort() ordena los items alfabéticamente o numéricamente 
.find() devuelve el primer elemento que cumple con una condición dada en una función de prueba ej edades = [25,18,30,15] let mayor = edades.find(edad => edad >= 18); devuelve 25, solo el primer match
algoritmos:
metodos de ordenacion:
bubble sort: ordena de menor a mayor con dos for. uno que recorra el array el número de items que tenga y otro que realice los swaps. osea un swap por step del for principal 

